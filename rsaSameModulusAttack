eA = 2064502724322065619610920801703770332444544578216378001086293531541437374183762889883952350512303123079541900923236233763161664622129759456230282585413446407867738585722011359806614520232070965281852076618382612714679676252453566235434477739937086238884216665488842132820363214479571428652601988484224495946375721070361900809019329649759575762397833605938043186770042654743067422241477268365617031178172027178755693566409032818917422094610812754447975895865178682453225583191912212367134587486285799782155109152944427348690163315056825740636659649124179137271843769782829849167189203185398850604993866726625112631363;

eB = 345876628472173658667827209598382151105659756356047916616789608178750837186397400300720629651340906876883086914495035331197886605204006436370260001522881159036935864943407229927853909159622840262574082310844414506912374854901914383942533751831444966354228432405145711811352973922639155549967535687324229764372344162085165004285404573177532292355481437060424009838888577080364530392886743183323043816768429349194326761737705660684396204279082233532281958218079492085884478114686098035666343747253331397342623111000982654071759143224287261895337445430397635372322031624510827582994475842436489318181834008077000862716;

cA = 599595716443335281998311836057824471423872949240946858680326885165189798248960569757894506358411805849585756670489287378663084704040194999917555981780947347168038953586881042265439088817588061113649282685562685793490922993153055756402440331270258091628957614506114564171089877371669425927413409680720072212671386711718210703493452595971294376452211824154369667228880216368587635945779792347579255888106682362545743068441745513171129264302343262741956564684731698919731241320987319631379148776964502682709221865993042999911089876791270600102273290388573803610119258785910206047147140049692741145838272637793573255535;

cB = 2770835070150439572361533458323853323331135769889806688952647723143090100332051468165048542378394448963218541675902047035925067679296545656936804088767980103951194340741696655103629403946052706547893699470917118074151642535282745768975138916426158727962237119890937352175934340987683034250582715361270008618676286594711314192182238464819951042936453477966710596316628687230956133831756510575129966303624319409792343130059271611653561066928057558199354900277398160189613164209414757242894166135226111274887275728717755076389566803028116652956415673871044558606548743531525162718902734213942283806624617372725072274578;

N = 2969137743448355327270876080101054338540503259878959630250143995627090090022850067465952425419364381562376747694180021046125245916815600955902349704778606351768446238203395142552910659278295524811626878015858630283055801066768074106075626751467085779562898859072146739523803688429510424565270597342059874774779917771627069956148632281761919668380478984737940333079018716867146763647145975313498463972109605022440637990931976478053161446536228883589512353452610817258565587291176075341583042418338206367482892585691607496654425794359814148329857831356779761901706016990032962092873983791585459395968897828575512138547;

#First, find the values of alpha and beta such that 1 = eA * alpha + eB * beta
#Use the extended Euclidean algorithm with a = eA and b = eB to calculate this

q = 0;
r = 0;
a = eA;
b = eB;
t21 = 0;
t22 = 0;
l11 = 1;
l12 = 0;
l21 = 0;
l22 = 1;

while b > 0:
    q = a // b;
    r = a % b;
    a = b;
    b = r;
    t21 = l21;
    t22 = l22;
    l21 = l11 - q * l21;
    l22 = l12 - q * l22;
    l11 = t21;
    l12 = t22;

print l11;
print l12;

alpha = l11;
beta = l12;

##At this point:
##
##alpha == -54757658640070026277373153508320349191862062943963599526410270111086739242970583119595450807036444777481669887086135100110080682667015005858680168103659618445784300010214934603910861446796585063713432256286844872157558274259356646876275736813221800912502149069437184312558512183238739389080205524994422464311190413687120706885275277424053668950668975297214155419901144141933140719398294600863483415800061785050529249723275638843144766710434064484796371212504856875471155682202850185368359112204043420577929684368959891137797448177416930477667141855848732148667439773004628141122951436838234054471217791329616021969
##beta == 326842943795542136131388887231748194396558586770160309243642890159405490611790943987284479429316660953441133005284064323005053864045297413721782876739412622391329538974536874168572736751884527475119667927069959809147533979991983942166765041610392537355006985362960363172821065996696463727474943721458109078544459158781466460796580527073621281368923229680894391283524619820857108446353233569570309661327714082026182018748651423555464788726121619575985714343257074481710573234451503660784969746628957757055136613377811460265617206006387463809679742541824587941728051765825600741547056253885241043345055066763224531603

#Since in this case alpha is negative, produce a positive value of alpha named posAlpha.
#Later, when cA is raised to the power of alpha mod N, it can instead be raised to posAlpha, and then the inverse mod N of the result can be found, since:
#(cA ^ alpha) mod N = ((cA ^ posAlpha) ^ -1) mod N

posAlpha = 0 - alpha;

#Find the binary strings of posAlpha and beta.

binPosAlpha = bin(posAlpha);
binBeta = bin(beta);

#The exponentiation method calculates a ^ p mod N, where p is very large.
#Uses a square-and-multiply method, based upon the binary string of the exponent.

def exponentiation(startVal, startExponMod, mod):
    running = 1;
    exponMod = startExponMod;
    for x in range(len(startVal)):
        startLoc = len(startVal) - x - 1;
        endLoc = startLoc + 1;
        digit = startVal[startLoc : endLoc];
        if digit == '1':
            running = (running * exponMod) % mod;
        exponMod = (exponMod * exponMod) % mod;
    return running;

cAToPowerPosAlpha = exponentiation(binPosAlpha, cA % N, N);

cBToPowerBeta = exponentiation(binBeta, cB % N, N);

#need to find inverse of cAToPowerPosAlpha mod N, since that is cAToPowerAlpha mod N
#Use the extended Euclidean algorithm

q = 0;
r = 0;
a = N;
b = cAToPowerPosAlpha;
t21 = 0;
t22 = 0;
l11 = 1;
l12 = 0;
l21 = 0;
l22 = 1;

while b > 0:
    q = a // b;
    r = a % b;
    a = b;
    b = r;
    t21 = l21;
    t22 = l22;
    l21 = l11 - q * l21;
    l22 = l12 - q * l22;
    l11 = t21;
    l12 = t22;

cAToPowerAlpha = l12;

#calculate m mod N using:
#m mod N = (cA ^ alpha * cB ^ beta) mod N

m = (cAToPowerAlpha * cBToPowerBeta) % N;

print m;

##At this point:
##
##m == 1241284880241822245031350316995316509613760031105566488758549213410379930768454638388105627962603033792604848852231910514447243725489419608385858883735979314364859728491299260062917200230440025398527707702850295624884577127897107255287191960914532074227602971007475556486214187806225594131456395882122963770810290613577965251307069511057382696768233468670233045728589973715388024931195704831783334623721062756711756350120344089464621935361024119741178566435368539009948622626793857657155673701127355633007181134673038573037510656910655350038503632683840012771185561459530291941543524137687560199607394816363851431902

#test that m is correct by encrypting with eA and eB to produce cAtest and cBtest, then comparing the encrypted values with cA and cB.
#If m is correct:
#cA - cAtest = 0
#cB - cBtest = 0


binEA = bin(eA);
binEB = bin(eB);

cAtest = exponentiation(binEA, m, N);
print (cA - cAtest);

cBtest = exponentiation(binEB, m, N);
print (cB - cBtest);
